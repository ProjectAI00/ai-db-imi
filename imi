#!/usr/bin/env bash
# imi — AI-native product ops state engine
# The shared brain for your AI coding agents.
#
# Install:  curl -fsSL https://imi.sh/install | bash
# Or:       curl -fsSL https://raw.githubusercontent.com/ProjectAI00/ai-imi/main/scripts/imi -o ~/.local/bin/imi && chmod +x ~/.local/bin/imi
#
# Any AI agent (Copilot, Claude Code, Cursor, etc.) can call these commands.
# Add to your project's CLAUDE.md / .github/copilot-instructions.md:
#   "Use `imi status` to see current goals/tasks. Use `imi complete <id> <summary>` when done."

set -euo pipefail

# --- Config ---
VERSION="0.2.0"

# DB discovery: check env, then project-local, then global
_find_db() {
  if [ -n "${IMI_DB:-}" ]; then echo "$IMI_DB"; return; fi
  # Project-local .imi/state.db (portable, works with any agent)
  local dir="${PWD}"
  while [ "$dir" != "/" ]; do
    if [ -f "$dir/.imi/state.db" ]; then echo "$dir/.imi/state.db"; return; fi
    dir="$(dirname "$dir")"
  done
  # Global fallback (shared with Electron app if installed)
  local global_db
  if [ "$(uname)" = "Darwin" ]; then
    global_db="$HOME/Library/Application Support/Agents Dev/data/agents.db"
  else
    global_db="${XDG_DATA_HOME:-$HOME/.local/share}/imi/state.db"
  fi
  echo "$global_db"
}

DB_PATH="$(_find_db)"

# --- Output mode: human (default), toon (compact for agents), json (verbose) ---
OUTPUT="${IMI_OUTPUT:-human}"
if [[ " $* " == *" --toon "* ]]; then OUTPUT="toon"; fi
if [[ " $* " == *" --json "* ]]; then OUTPUT="json"; fi

# --- Colors (disabled in machine modes or non-TTY) ---
if [ "$OUTPUT" != "human" ] || [ ! -t 1 ]; then
  RED=''; GREEN=''; YELLOW=''; BLUE=''; CYAN=''; DIM=''; BOLD=''; NC=''
else
  RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'
  BLUE='\033[0;34m'; CYAN='\033[0;36m'; DIM='\033[2m'; BOLD='\033[1m'; NC='\033[0m'
fi

# Strip output flags from args
ARGS=()
for arg in "$@"; do [ "$arg" != "--json" ] && [ "$arg" != "--toon" ] && ARGS+=("$arg"); done
set -- "${ARGS[@]+"${ARGS[@]}"}"

# --- Auto-init DB if missing ---
_init_db() {
  local db_dir
  db_dir="$(dirname "$DB_PATH")"
  mkdir -p "$db_dir"
  sqlite3 "$DB_PATH" <<'SQL'
CREATE TABLE IF NOT EXISTS goals (
  id TEXT PRIMARY KEY NOT NULL,
  name TEXT NOT NULL,
  description TEXT NOT NULL,
  why TEXT,
  for_who TEXT,
  success_signal TEXT,
  out_of_scope TEXT,
  workspace_id TEXT,
  status TEXT NOT NULL DEFAULT 'todo',
  priority TEXT NOT NULL DEFAULT 'medium',
  context TEXT,
  tags TEXT DEFAULT '[]',
  workspace_path TEXT,
  relevant_files TEXT DEFAULT '[]',
  created_at INTEGER,
  updated_at INTEGER,
  completed_at INTEGER
);
CREATE TABLE IF NOT EXISTS tasks (
  id TEXT PRIMARY KEY NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  why TEXT,
  context TEXT,
  linked_files TEXT DEFAULT '[]',
  project_id TEXT,
  workspace_id TEXT,
  assignee_type TEXT NOT NULL DEFAULT 'ai',
  agent_id TEXT,
  team_id TEXT,
  tags TEXT DEFAULT '[]',
  time_frame TEXT NOT NULL DEFAULT 'this_week',
  due_date INTEGER,
  priority TEXT NOT NULL DEFAULT 'medium',
  status TEXT NOT NULL DEFAULT 'todo',
  chat_id TEXT,
  summary TEXT,
  goal_id TEXT REFERENCES goals(id) ON DELETE SET NULL,
  plan_id TEXT,
  execution_format TEXT DEFAULT 'json',
  execution_payload TEXT,
  workspace_path TEXT,
  relevant_files TEXT DEFAULT '[]',
  tools TEXT DEFAULT '[]',
  acceptance_criteria TEXT,
  created_at INTEGER,
  updated_at INTEGER,
  completed_at INTEGER,
  created_by TEXT NOT NULL DEFAULT 'user'
);
CREATE TABLE IF NOT EXISTS memories (
  id TEXT PRIMARY KEY NOT NULL,
  goal_id TEXT REFERENCES goals(id) ON DELETE SET NULL,
  task_id TEXT REFERENCES tasks(id) ON DELETE SET NULL,
  key TEXT NOT NULL,
  value TEXT NOT NULL,
  type TEXT NOT NULL DEFAULT 'learning',
  reasoning TEXT,
  source TEXT NOT NULL DEFAULT 'agent',
  created_at INTEGER
);
CREATE INDEX IF NOT EXISTS memories_goal_id_idx ON memories(goal_id);
CREATE TABLE IF NOT EXISTS workspaces (
  id TEXT PRIMARY KEY NOT NULL,
  name TEXT NOT NULL,
  path TEXT NOT NULL,
  git_remote TEXT,
  created_at INTEGER,
  updated_at INTEGER
);
CREATE INDEX IF NOT EXISTS workspaces_path_idx ON workspaces(path);
CREATE TABLE IF NOT EXISTS decisions (
  id TEXT PRIMARY KEY NOT NULL,
  what TEXT NOT NULL,
  why TEXT NOT NULL,
  affects TEXT,
  created_at INTEGER
);
CREATE TABLE IF NOT EXISTS direction_notes (
  id TEXT PRIMARY KEY NOT NULL,
  content TEXT NOT NULL,
  author TEXT,
  created_at INTEGER
);
CREATE TABLE IF NOT EXISTS events (
  id TEXT PRIMARY KEY NOT NULL,
  command TEXT NOT NULL,
  task_id TEXT,
  goal_id TEXT,
  agent_id TEXT,
  duration_ms INTEGER DEFAULT 0,
  created_at INTEGER
);
CREATE INDEX IF NOT EXISTS events_command_idx ON events(command);
CREATE INDEX IF NOT EXISTS events_created_at_idx ON events(created_at);
SQL
}

ensure_db() {
  local is_new=0
  [ ! -f "$DB_PATH" ] && is_new=1
  _init_db  # always run — all CREATE IF NOT EXISTS, fully idempotent
  if [ $is_new -eq 1 ] && [ "$OUTPUT" = "human" ]; then
    echo -e "${GREEN}●${NC} Initialized IMI database at ${DIM}$DB_PATH${NC}"
  fi
}

# Fire-and-forget behavioral telemetry — never crashes imi
_track() {
  local cmd="${1:-}" tid="${2:-}" gid="${3:-}"
  local id; id=$(gen_id)
  local agent="${IMI_AGENT_ID:-${USER:-agent}}"
  sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO events (id,command,task_id,goal_id,agent_id,duration_ms,created_at) VALUES ('$id','$(sql_escape "$cmd")','$(sql_escape "$tid")','$(sql_escape "$gid")','$(sql_escape "$agent")',0,$(now_ms))" 2>/dev/null || true
}

sql() {
  sqlite3 -json "$DB_PATH" "$1" 2>/dev/null
}

sql_json() {
  sqlite3 "$DB_PATH" "$1" 2>/dev/null
}

sql_raw() {
  sqlite3 "$DB_PATH" "$1" 2>/dev/null
}

sql_exec() {
  sqlite3 "$DB_PATH" "$1" 2>/dev/null
}

sql_escape() { printf "%s" "$1" | sed "s/'/''/g"; }

now_ms() {
  if command -v python3 >/dev/null 2>&1; then
    python3 -c "import time; print(int(time.time()*1000))"
  else
    echo "$(( $(date +%s) * 1000 ))"
  fi
}

gen_id() {
  if command -v python3 >/dev/null 2>&1; then
    python3 -c "
import time, random
ts = int(time.time() * 1000)
base36_ts = ''
n = ts
while n > 0:
    base36_ts = '0123456789abcdefghijklmnopqrstuvwxyz'[n % 36] + base36_ts
    n //= 36
rand = ''.join(random.choices('0123456789abcdefghijklmnopqrstuvwxyz', k=8))
print(base36_ts + rand)
"
  else
    printf '%x%s\n' "$(date +%s)" "$(LC_ALL=C tr -dc a-z0-9 </dev/urandom 2>/dev/null | head -c 8 || cat /dev/urandom | LC_ALL=C tr -dc a-z0-9 | head -c 8)"
  fi
}

current_user() {
  git config user.name 2>/dev/null || echo "${USER:-unknown}"
}

# Output helpers
machine_out() { [ "$OUTPUT" = "json" ] || [ "$OUTPUT" = "toon" ]; }

# TOON (Token-Oriented Object Notation) — header once, CSV rows with 2-space indent
# Spec: name[count]{f1,f2}:\n  v1,v2
toon_escape() { printf "%s" "$1" | sed 's/,/\\,/g'; }
# Print a TOON section from a sql_raw result (pipe-separated rows)
# Usage: toon_section "name" "f1,f2,f3" "$(sql_raw "SELECT a||'|'||b||'|'||c FROM ...")"
toon_section() {
  local name="$1" fields="$2" rows="$3"
  [ -z "$rows" ] && return
  local count; count=$(echo "$rows" | grep -c .)
  echo "${name}[${count}]{${fields}}:"
  echo "$rows" | while IFS='|' read -r line; do
    # re-escape commas in each field
    local out="" IFS_OLD="$IFS"; IFS='|'
    local -a parts=($line); IFS="$IFS_OLD"
    for p in "${parts[@]}"; do out="${out}$(toon_escape "$p"),"; done
    echo "  ${out%,}"
  done
}

# Stale-lock: tasks in_progress >30min with no activity → revert to todo
_unlock_stale() {
  local stale_ms; stale_ms=$(( $(now_ms) - 1800000 ))
  local stale_count
  stale_count=$(sql_raw "SELECT count(*) FROM tasks WHERE status='in_progress' AND updated_at < $stale_ms" 2>/dev/null || echo "0")
  if [ "$stale_count" != "0" ]; then
    sql_exec "UPDATE tasks SET status='todo', agent_id=NULL, updated_at=$(now_ms) WHERE status='in_progress' AND updated_at < $stale_ms"
    local note_id; note_id=$(gen_id)
    sql_exec "INSERT INTO direction_notes (id, content, author, created_at) VALUES ('$(sql_escape "$note_id")', 'Auto-unlocked $stale_count stale task(s) (no activity >30min)', 'imi', $(now_ms))"
  fi
}

status_icon() {
  case "$1" in
    todo)        echo "○" ;;
    in_progress) echo "◐" ;;
    ongoing)     echo "◐" ;;
    review)      echo "◑" ;;
    done)        echo "●" ;;
    blocked)     echo "✕" ;;
    *)           echo "?" ;;
  esac
}

status_color() {
  case "$1" in
    todo)        echo "$DIM" ;;
    in_progress) echo "$YELLOW" ;;
    ongoing)     echo "$YELLOW" ;;
    review)      echo "$CYAN" ;;
    done)        echo "$GREEN" ;;
    blocked)     echo "$RED" ;;
    *)           echo "$NC" ;;
  esac
}

priority_label() {
  case "$1" in
    high)   echo -e "${RED}▲${NC}" ;;
    medium) echo -e "${YELLOW}■${NC}" ;;
    low)    echo -e "${DIM}▽${NC}" ;;
    *)      echo " " ;;
  esac
}

time_ago() {
  local ms_ts="$1"
  if [ -z "$ms_ts" ] || [ "$ms_ts" = "null" ]; then echo "—"; return; fi
  python3 -c "
import time
diff = time.time() - ($ms_ts / 1000)
if diff < 60: print(f'{int(diff)}s ago')
elif diff < 3600: print(f'{int(diff/60)}m ago')
elif diff < 86400: print(f'{int(diff/3600)}h ago')
else: print(f'{int(diff/86400)}d ago')
"
}

# --- Commands ---

cmd_status() {
  ensure_db
  _unlock_stale

  if [ "$OUTPUT" = "json" ]; then
    sql_json "SELECT json_object(
      'goals', (SELECT json_group_array(json_object(
        'id', g.id, 'name', g.name, 'status', g.status, 'priority', g.priority,
        'tasks_total', (SELECT count(*) FROM tasks WHERE goal_id=g.id),
        'tasks_done', (SELECT count(*) FROM tasks WHERE goal_id=g.id AND status='done'),
        'tasks', (SELECT json_group_array(json_object(
          'id', t.id, 'title', t.title, 'status', t.status, 'priority', t.priority,
          'summary', t.summary, 'agent_id', t.agent_id
        )) FROM tasks t WHERE t.goal_id=g.id)
      )) FROM goals g),
      'stats', json_object(
        'goals', (SELECT count(*) FROM goals),
        'tasks', (SELECT count(*) FROM tasks),
        'done', (SELECT count(*) FROM tasks WHERE status='done'),
        'in_progress', (SELECT count(*) FROM tasks WHERE status='in_progress'),
        'memories', (SELECT count(*) FROM memories)
      )
    )"
    return
  fi

  local goals tasks_total tasks_done tasks_progress tasks_review memories
  goals=$(sql_raw "SELECT count(*) FROM goals")
  tasks_total=$(sql_raw "SELECT count(*) FROM tasks")
  tasks_done=$(sql_raw "SELECT count(*) FROM tasks WHERE status='done'")
  tasks_progress=$(sql_raw "SELECT count(*) FROM tasks WHERE status='in_progress'")
  tasks_review=$(sql_raw "SELECT count(*) FROM tasks WHERE status='review'")
  memories=$(sql_raw "SELECT count(*) FROM memories")

  echo -e "${BOLD}IMI State Engine${NC}  ${DIM}v${VERSION}${NC}"
  echo -e "${DIM}DB: $DB_PATH${NC}"
  echo ""
  echo -e "  ${BOLD}Goals${NC}       $goals"
  echo -e "  ${BOLD}Tasks${NC}       $tasks_total  ${GREEN}●${tasks_done} done${NC}  ${YELLOW}◐${tasks_progress} wip${NC}  ${CYAN}◑${tasks_review} review${NC}  ${DIM}○$((tasks_total - tasks_done - tasks_progress - tasks_review)) todo${NC}"
  echo -e "  ${BOLD}Memories${NC}    $memories"
  echo ""

  # Stale-lock warning
  local stale_ms; stale_ms=$(( $(now_ms) - 1800000 ))
  local stale_wip; stale_wip=$(sql_raw "SELECT count(*) FROM tasks WHERE status='in_progress' AND updated_at < $stale_ms")
  [ "$stale_wip" != "0" ] && echo -e "  ${RED}⚠  $stale_wip stale task(s) in_progress >30min — run \`imi status\` again to auto-unlock${NC}" && echo ""

  while IFS='|' read -r gid gname gstatus gpriority; do
    [ -z "$gid" ] && continue
    local icon sc
    icon=$(status_icon "$gstatus")
    sc=$(status_color "$gstatus")
    local done_count total_count
    done_count=$(sql_raw "SELECT count(*) FROM tasks WHERE goal_id='$gid' AND status='done'")
    total_count=$(sql_raw "SELECT count(*) FROM tasks WHERE goal_id='$gid'")
    echo -e "  ${sc}${icon}${NC} $(priority_label "$gpriority") ${BOLD}${gname}${NC}  ${DIM}(${done_count}/${total_count})${NC}  ${DIM}${gid:0:10}${NC}"

    while IFS='|' read -r tid ttitle tstatus tpriority tassignee; do
      [ -z "$tid" ] && continue
      local ticon tsc
      ticon=$(status_icon "$tstatus")
      tsc=$(status_color "$tstatus")
      local assignee_str=""; [ -n "$tassignee" ] && assignee_str="  ${DIM}@${tassignee}${NC}"
      echo -e "    ${tsc}${ticon}${NC} $(priority_label "$tpriority") ${ttitle}${assignee_str}  ${DIM}${tid:0:10}${NC}"
    done < <(sql_raw "SELECT id, title, status, priority, agent_id FROM tasks WHERE goal_id='$gid' ORDER BY CASE status WHEN 'in_progress' THEN 0 WHEN 'review' THEN 1 WHEN 'todo' THEN 2 WHEN 'done' THEN 3 END, created_at" ".separator |")
    echo ""
  done < <(sql_raw "SELECT id, name, status, priority FROM goals ORDER BY CASE status WHEN 'ongoing' THEN 0 WHEN 'in_progress' THEN 0 WHEN 'review' THEN 1 WHEN 'todo' THEN 2 WHEN 'done' THEN 3 END, created_at" ".separator |")
}

cmd_goals() {

  echo -e "${BOLD}IMI State Engine${NC}  ${DIM}v${VERSION}${NC}"
  echo -e "${DIM}DB: $DB_PATH${NC}"
  echo ""
  echo -e "  ${BOLD}Goals${NC}       $goals"
  echo -e "  ${BOLD}Tasks${NC}       $tasks_total  ${GREEN}●${tasks_done} done${NC}  ${YELLOW}◐${tasks_progress} wip${NC}  ${CYAN}◑${tasks_review} review${NC}  ${DIM}○$((tasks_total - tasks_done - tasks_progress - tasks_review)) todo${NC}"
  echo -e "  ${BOLD}Memories${NC}    $memories"
  echo ""

  while IFS='|' read -r gid gname gstatus gpriority; do
    [ -z "$gid" ] && continue
    local icon sc
    icon=$(status_icon "$gstatus")
    sc=$(status_color "$gstatus")
    local done_count total_count
    done_count=$(sql_raw "SELECT count(*) FROM tasks WHERE goal_id='$gid' AND status='done'")
    total_count=$(sql_raw "SELECT count(*) FROM tasks WHERE goal_id='$gid'")
    echo -e "  ${sc}${icon}${NC} $(priority_label "$gpriority") ${BOLD}${gname}${NC}  ${DIM}(${done_count}/${total_count})${NC}  ${DIM}${gid:0:10}${NC}"
    
    while IFS='|' read -r tid ttitle tstatus tpriority; do
      [ -z "$tid" ] && continue
      local ticon tsc
      ticon=$(status_icon "$tstatus")
      tsc=$(status_color "$tstatus")
      echo -e "    ${tsc}${ticon}${NC} $(priority_label "$tpriority") ${ttitle}  ${DIM}${tid:0:10}${NC}"
    done < <(sql_raw "SELECT id, title, status, priority FROM tasks WHERE goal_id='$gid' ORDER BY CASE status WHEN 'in_progress' THEN 0 WHEN 'review' THEN 1 WHEN 'todo' THEN 2 WHEN 'done' THEN 3 END, created_at" ".separator |")
    echo ""
  done < <(sql_raw "SELECT id, name, status, priority FROM goals ORDER BY CASE status WHEN 'ongoing' THEN 0 WHEN 'in_progress' THEN 0 WHEN 'review' THEN 1 WHEN 'todo' THEN 2 WHEN 'done' THEN 3 END, created_at" ".separator |")
}

cmd_goals() {
  ensure_db
  if [ "$OUTPUT" = "json" ]; then
    sql_json "SELECT json_group_array(json_object('id', id, 'name', name, 'status', status, 'priority', priority, 'description', description)) FROM goals ORDER BY created_at DESC"
    return
  fi
  echo -e "${BOLD}Goals${NC}"
  echo ""
  while IFS='|' read -r gid gname gstatus gpriority gcreated; do
    [ -z "$gid" ] && continue
    local icon sc ago
    icon=$(status_icon "$gstatus")
    sc=$(status_color "$gstatus")
    ago=$(time_ago "$gcreated")
    local done_count total_count
    done_count=$(sql_raw "SELECT count(*) FROM tasks WHERE goal_id='$gid' AND status='done'")
    total_count=$(sql_raw "SELECT count(*) FROM tasks WHERE goal_id='$gid'")
    echo -e "  ${sc}${icon}${NC} $(priority_label "$gpriority") ${BOLD}${gname}${NC}"
    echo -e "    ${DIM}${gid}  ${done_count}/${total_count} tasks  ${ago}${NC}"
  done < <(sql_raw "SELECT id, name, status, priority, created_at FROM goals ORDER BY created_at DESC" ".separator |")
}

cmd_tasks() {
  ensure_db
  local filter="${1:-all}"
  
  local where_clause=""
  case "$filter" in
    todo)    where_clause="WHERE t.status='todo'" ;;
    wip)     where_clause="WHERE t.status='in_progress'" ;;
    review)  where_clause="WHERE t.status='review'" ;;
    done)    where_clause="WHERE t.status='done'" ;;
    all)     where_clause="" ;;
    *)
      local resolved_gid
      resolved_gid=$(sql_raw "SELECT id FROM goals WHERE id LIKE '$(sql_escape "$filter")%' LIMIT 1")
      if [ -n "$resolved_gid" ]; then
        where_clause="WHERE t.goal_id='$(sql_escape "$resolved_gid")'"
      else
        where_clause="WHERE t.id LIKE '$(sql_escape "$filter")%'"
      fi
      ;;
  esac

  if [ "$OUTPUT" = "json" ]; then
    sql_json "SELECT json_group_array(json_object('id', t.id, 'title', t.title, 'status', t.status, 'priority', t.priority, 'summary', t.summary, 'goal_id', t.goal_id, 'goal_name', g.name, 'description', t.description, 'agent_id', t.agent_id, 'workspace_path', t.workspace_path)) FROM tasks t LEFT JOIN goals g ON t.goal_id=g.id $where_clause ORDER BY t.created_at"
    return
  fi

  echo -e "${BOLD}Tasks${NC}  ${DIM}(filter: $filter)${NC}"
  echo ""

  while IFS='|' read -r tid ttitle tstatus tpriority gname tassignee; do
    [ -z "$tid" ] && continue
    local icon sc
    icon=$(status_icon "$tstatus")
    sc=$(status_color "$tstatus")
    local assignee_str=""
    [ -n "$tassignee" ] && assignee_str="  ${DIM}← $tassignee${NC}"
    echo -e "  ${sc}${icon}${NC} $(priority_label "$tpriority") ${ttitle}${assignee_str}"
    echo -e "    ${DIM}${tid}  ← ${gname:-no goal}${NC}"
  done < <(sql_raw "SELECT t.id, t.title, t.status, t.priority, g.name, t.agent_id FROM tasks t LEFT JOIN goals g ON t.goal_id=g.id $where_clause ORDER BY CASE t.status WHEN 'in_progress' THEN 0 WHEN 'review' THEN 1 WHEN 'todo' THEN 2 WHEN 'done' THEN 3 END, t.created_at" ".separator |")
}

cmd_context() {
  ensure_db
  _unlock_stale
  _track "context" "" ""
  local target="${1:-}"

  if [ "$OUTPUT" = "json" ]; then
    if [ -z "$target" ]; then
      sql_json "SELECT json_object(
        'direction', (SELECT json_group_array(json_object('content',d.content,'author',d.author,'created_at',d.created_at)) FROM direction_notes d ORDER BY d.created_at DESC LIMIT 5),
        'decisions', (SELECT json_group_array(json_object('what',d.what,'why',d.why,'affects',d.affects,'created_at',d.created_at)) FROM decisions d ORDER BY d.created_at DESC LIMIT 5),
        'goals', (SELECT json_group_array(json_object(
          'id',g.id,'name',g.name,'status',g.status,'priority',g.priority,
          'description',g.description,'why',g.why,'for_who',g.for_who,
          'success_signal',g.success_signal,'out_of_scope',g.out_of_scope,
          'tasks_done',(SELECT count(*) FROM tasks WHERE goal_id=g.id AND status='done'),
          'tasks_total',(SELECT count(*) FROM tasks WHERE goal_id=g.id)
        )) FROM goals g WHERE g.status!='done' ORDER BY g.updated_at DESC),
        'in_progress_tasks', (SELECT json_group_array(json_object('id',t.id,'title',t.title,'why',t.why,'goal',g.name,'agent_id',t.agent_id)) FROM tasks t JOIN goals g ON t.goal_id=g.id WHERE t.status='in_progress'),
        'memories', (SELECT json_group_array(json_object('key',m.key,'value',m.value,'type',m.type)) FROM memories m ORDER BY m.created_at DESC LIMIT 20)
      )"
    else
      local full_gid
      full_gid=$(sql_raw "SELECT id FROM goals WHERE id LIKE '${target}%' LIMIT 1")
      [ -z "$full_gid" ] && echo '{"error":"Goal not found"}' && return 1
      sql_json "SELECT json_object(
        'id','$full_gid',
        'name',(SELECT name FROM goals WHERE id='$full_gid'),
        'status',(SELECT status FROM goals WHERE id='$full_gid'),
        'description',(SELECT description FROM goals WHERE id='$full_gid'),
        'why',(SELECT why FROM goals WHERE id='$full_gid'),
        'for_who',(SELECT for_who FROM goals WHERE id='$full_gid'),
        'success_signal',(SELECT success_signal FROM goals WHERE id='$full_gid'),
        'out_of_scope',(SELECT out_of_scope FROM goals WHERE id='$full_gid'),
        'tasks',(SELECT json_group_array(json_object('id',t.id,'title',t.title,'status',t.status,'why',t.why,'summary',t.summary,'description',t.description,'agent_id',t.agent_id)) FROM tasks t WHERE t.goal_id='$full_gid' ORDER BY t.updated_at DESC),
        'memories',(SELECT json_group_array(json_object('key',m.key,'value',m.value,'type',m.type,'reasoning',m.reasoning)) FROM memories m WHERE m.goal_id='$full_gid' ORDER BY m.created_at DESC),
        'decisions',(SELECT json_group_array(json_object('what',d.what,'why',d.why,'affects',d.affects,'created_at',d.created_at)) FROM decisions d WHERE d.affects LIKE '%$full_gid%' ORDER BY d.created_at DESC)
      )"
    fi
    return
  fi

  # TOON output — compact for agents
  if [ "$OUTPUT" = "toon" ]; then
    if [ -z "$target" ]; then
      local week_ago; week_ago=$(python3 -c "import time; print(int((time.time()-604800)*1000))" 2>/dev/null || echo "0")
      toon_section "direction" "content,author" \
        "$(sql_raw "SELECT content||'|'||coalesce(author,'') FROM direction_notes WHERE created_at > $week_ago ORDER BY created_at DESC LIMIT 5")"
      toon_section "decisions" "what,why,affects" \
        "$(sql_raw "SELECT what||'|'||why||'|'||coalesce(affects,'') FROM decisions ORDER BY created_at DESC LIMIT 3")"
      toon_section "goals" "id,name,status,why,done,total" \
        "$(sql_raw "SELECT g.id||'|'||g.name||'|'||g.status||'|'||coalesce(g.why,'')||'|'||(SELECT count(*) FROM tasks WHERE goal_id=g.id AND status='done')||'|'||(SELECT count(*) FROM tasks WHERE goal_id=g.id) FROM goals g WHERE g.status!='done' ORDER BY g.updated_at DESC")"
      toon_section "wip" "id,title,goal,agent" \
        "$(sql_raw "SELECT t.id||'|'||t.title||'|'||g.name||'|'||coalesce(t.agent_id,'') FROM tasks t JOIN goals g ON t.goal_id=g.id WHERE t.status='in_progress'")"
      toon_section "memories" "key,value,type" \
        "$(sql_raw "SELECT key||'|'||value||'|'||coalesce(type,'') FROM memories ORDER BY created_at DESC LIMIT 10")"
    fi
    return
  fi

  if [ -z "$target" ]; then
    echo -e "${BOLD}IMI Context${NC}  ${DIM}what matters right now${NC}"
    echo ""

    # Recent direction notes (last 7 days)
    local note_count
    local week_ago
    week_ago=$(python3 -c "import time; print(int((time.time()-604800)*1000))" 2>/dev/null || echo "0")
    note_count=$(sql_raw "SELECT count(*) FROM direction_notes WHERE created_at > $week_ago")
    if [ "$note_count" != "0" ]; then
      echo -e "${CYAN}Direction  ${DIM}(last 7 days)${NC}"
      while IFS='|' read -r content author ts; do
        [ -z "$content" ] && continue
        local ago; ago=$(time_ago "$ts")
        local author_str=""; [ -n "$author" ] && author_str="  @$author"
        echo -e "  ${YELLOW}▸${NC} $content"
        echo -e "    ${DIM}${ago}${author_str}${NC}"
      done < <(sql_raw "SELECT content, author, created_at FROM direction_notes WHERE created_at > $week_ago ORDER BY created_at DESC LIMIT 5" ".separator |")
      echo ""
    fi

    # Latest decisions
    local dec_count
    dec_count=$(sql_raw "SELECT count(*) FROM decisions")
    if [ "$dec_count" != "0" ]; then
      echo -e "${CYAN}Decisions  ${DIM}(most recent first)${NC}"
      while IFS='|' read -r what why affects ts; do
        [ -z "$what" ] && continue
        local ago; ago=$(time_ago "$ts")
        echo -e "  ${BOLD}$what${NC}"
        echo -e "    ${DIM}why: $why${NC}"
        [ -n "$affects" ] && echo -e "    ${DIM}affects: $affects${NC}"
        echo -e "    ${DIM}$ago${NC}"
      done < <(sql_raw "SELECT what, why, affects, created_at FROM decisions ORDER BY created_at DESC LIMIT 3" ".separator |")
      echo ""
    fi

    # Active goals ordered by most recently updated
    echo -e "${CYAN}Active Goals  ${DIM}(recent first)${NC}"
    while IFS='|' read -r gname gstatus done_ct total_ct gwhy gts; do
      [ -z "$gname" ] && continue
      local ago; ago=$(time_ago "$gts")
      echo -e "  $(status_icon "$gstatus") ${BOLD}$gname${NC}  ${DIM}($done_ct/$total_ct)  $ago${NC}"
      [ -n "$gwhy" ] && echo -e "    ${DIM}why: $gwhy${NC}"
    done < <(sql_raw "SELECT g.name, g.status, (SELECT count(*) FROM tasks WHERE goal_id=g.id AND status='done'), (SELECT count(*) FROM tasks WHERE goal_id=g.id), g.why, g.updated_at FROM goals g WHERE g.status != 'done' ORDER BY g.updated_at DESC" ".separator |")

    echo ""
    echo -e "${CYAN}In Progress${NC}"
    local wip_count
    wip_count=$(sql_raw "SELECT count(*) FROM tasks WHERE status='in_progress'")
    if [ "$wip_count" = "0" ]; then
      echo -e "  ${DIM}(nothing in progress)${NC}"
    else
      while IFS='|' read -r ttitle gname tassignee; do
        [ -z "$ttitle" ] && continue
        local a=""
        [ -n "$tassignee" ] && a="  ${DIM}@${tassignee}${NC}"
        echo -e "  ◐ $ttitle  ${DIM}← $gname${NC}$a"
      done < <(sql_raw "SELECT t.title, g.name, t.agent_id FROM tasks t JOIN goals g ON t.goal_id=g.id WHERE t.status='in_progress'" ".separator |")
    fi

  else
    local goal_row
    goal_row=$(sql_raw "SELECT id, name, description, status, why, for_who, success_signal, out_of_scope FROM goals WHERE id LIKE '$(sql_escape "$target")%' LIMIT 1" ".separator |")
    if [ -z "$goal_row" ]; then
      echo -e "${RED}Goal not found: $target${NC}"
      return 1
    fi
    IFS='|' read -r gid gname gdesc gstatus gwhy gfor gsig gscope <<< "$goal_row"
    echo -e "${BOLD}$gname${NC}  $(status_icon "$gstatus") $gstatus"
    [ -n "$gdesc" ] && echo -e "${DIM}$gdesc${NC}"
    [ -n "$gwhy" ] && echo -e "\n${CYAN}Why:${NC} $gwhy"
    [ -n "$gfor" ] && echo -e "${CYAN}For:${NC} $gfor"
    [ -n "$gsig" ] && echo -e "${CYAN}Done when:${NC} $gsig"
    [ -n "$gscope" ] && echo -e "${CYAN}Not doing:${NC} $gscope"

    echo ""
    echo -e "${CYAN}Tasks:${NC}"
    while IFS='|' read -r tid ttitle tstatus twhy tsummary tassignee; do
      [ -z "$tid" ] && continue
      local a=""; [ -n "$tassignee" ] && a=" @${tassignee}"
      echo -e "  $(status_icon "$tstatus") $ttitle${DIM}$a${NC}  ${DIM}${tid:0:10}${NC}"
      [ -n "$twhy" ] && echo -e "    ${DIM}why: $twhy${NC}"
      [ -n "$tsummary" ] && echo -e "    ${DIM}↳ $tsummary${NC}"
    done < <(sql_raw "SELECT id, title, status, why, summary, agent_id FROM tasks WHERE goal_id='$gid' ORDER BY updated_at DESC" ".separator |")

    echo ""
    echo -e "${CYAN}Memories:${NC}"
    local mem_count
    mem_count=$(sql_raw "SELECT count(*) FROM memories WHERE goal_id='$gid'")
    if [ "$mem_count" = "0" ]; then
      echo -e "  ${DIM}(none)${NC}"
    else
      while IFS='|' read -r mkey mvalue mtype; do
        [ -z "$mkey" ] && continue
        local type_label=""; [ -n "$mtype" ] && type_label=" ${DIM}[$mtype]${NC}"
        echo -e "  ${BOLD}$mkey${NC}$type_label: $mvalue"
      done < <(sql_raw "SELECT key, value, type FROM memories WHERE goal_id='$gid' ORDER BY created_at DESC" ".separator |")
    fi
  fi
}

cmd_add_goal() {
  ensure_db
  local name="${1:?Usage: imi add-goal <name> [description] [priority] [why] [for_who] [success_signal]}"
  local desc="${2:-$name}"
  local priority="${3:-medium}"
  local why="${4:-}"
  local for_who="${5:-}"
  local success_signal="${6:-}"
  local id workspace_path
  id=$(gen_id)
  workspace_path="$(pwd)"

  local ws_id
  ws_id=$(sql_raw "SELECT id FROM workspaces WHERE path='$(sql_escape "$workspace_path")' LIMIT 1")

  sql_exec "INSERT INTO goals (id, name, description, why, for_who, success_signal, status, priority, context, tags, workspace_id, workspace_path, relevant_files, created_at, updated_at) VALUES ('$(sql_escape "$id")', '$(sql_escape "$name")', '$(sql_escape "$desc")', '$(sql_escape "$why")', '$(sql_escape "$for_who")', '$(sql_escape "$success_signal")', 'todo', '$(sql_escape "$priority")', '', '[]', '$(sql_escape "$ws_id")', '$(sql_escape "$workspace_path")', '[]', $(now_ms), $(now_ms))"

  if [ "$OUTPUT" = "json" ]; then
    echo "{\"ok\":true,\"id\":\"$id\",\"name\":\"$name\"}"
    return
  fi
  echo -e "${GREEN}●${NC} Goal created: ${BOLD}$name${NC}"
  [ -n "$why" ] && echo -e "  ${DIM}why: $why${NC}"
  echo -e "  ${DIM}$id${NC}"
}

cmd_add_task() {
  ensure_db
  local goal_id="${1:?Usage: imi add-task <goal_id> <title> [description] [priority] [why]}"
  local title="${2:?Usage: imi add-task <goal_id> <title> [description] [priority] [why]}"
  local desc="${3:-$title}"
  local priority="${4:-medium}"
  local why="${5:-}"

  # Resolve partial goal ID
  local full_gid
  full_gid=$(sql_raw "SELECT id FROM goals WHERE id LIKE '${goal_id}%' LIMIT 1")
  if [ -z "$full_gid" ]; then
    echo -e "${RED}Goal not found: $goal_id${NC}"
    return 1
  fi

  local id
  id=$(gen_id)

  local ws_path
  ws_path=$(sql_raw "SELECT workspace_path FROM goals WHERE id='$(sql_escape "$full_gid")'")

  sql_exec "INSERT INTO tasks (id, title, description, why, status, priority, goal_id, workspace_path, assignee_type, created_by, created_at, updated_at) VALUES ('$(sql_escape "$id")', '$(sql_escape "$title")', '$(sql_escape "$desc")', '$(sql_escape "$why")', 'todo', '$(sql_escape "$priority")', '$(sql_escape "$full_gid")', '$(sql_escape "$ws_path")', 'ai', '$(sql_escape "$(current_user)")', $(now_ms), $(now_ms))"

  if [ "$OUTPUT" = "json" ]; then
    echo "{\"ok\":true,\"id\":\"$id\",\"goal_id\":\"$full_gid\",\"title\":\"$title\"}"
    return
  fi
  echo -e "${GREEN}●${NC} Task created: ${BOLD}$title${NC}"
  [ -n "$why" ] && echo -e "  ${DIM}why: $why${NC}"
  echo -e "  ${DIM}$id → goal $full_gid${NC}"
}

cmd_start() {
  ensure_db
  local task_id="${1:?Usage: imi start <task_id>}"
  
  local full_tid
  full_tid=$(sql_raw "SELECT id FROM tasks WHERE id LIKE '${task_id}%' LIMIT 1")
  if [ -z "$full_tid" ]; then
    echo -e "${RED}Task not found: $task_id${NC}"
    return 1
  fi
  
  local agent
  agent=$(current_user)
  sql_exec "UPDATE tasks SET status='in_progress', agent_id='$(sql_escape "$agent")', updated_at=$(now_ms) WHERE id='$(sql_escape "$full_tid")'"
  
  # Sync goal
  local goal_id
  goal_id=$(sql_raw "SELECT goal_id FROM tasks WHERE id='$full_tid'")
  if [ -n "$goal_id" ]; then
    _sync_goal "$goal_id"
  fi
  
  local title
  title=$(sql_raw "SELECT title FROM tasks WHERE id='$full_tid'")
  if [ "$OUTPUT" = "json" ]; then
    echo "{\"ok\":true,\"id\":\"$full_tid\",\"status\":\"in_progress\",\"title\":\"$title\",\"agent\":\"$agent\"}"
    return
  fi
  echo -e "${YELLOW}◐${NC} Started: ${BOLD}$title${NC}  ${DIM}@${agent}${NC}"
}

cmd_complete() {
  ensure_db
  local agent; agent=$(current_user)
  if [ "${1:-}" = "--agent" ]; then
    local agent_name="${2:-}"
    if [ -z "$agent_name" ]; then
      if machine_out; then echo '{"ok":false,"error":"Usage: imi complete [--agent <name>] <task_id> [summary]"}'; fi
      return 1
    fi
    agent="$agent_name"
    shift 2
  fi
  local task_id="${1:?Usage: imi complete [--agent <name>] <task_id> [summary]}"
  local summary="${2:-Task completed}"

  local full_tid
  full_tid=$(sql_raw "SELECT id FROM tasks WHERE id LIKE '${task_id}%' LIMIT 1")
  if [ -z "$full_tid" ]; then
    if machine_out; then echo '{"ok":false,"error":"Task not found"}'; fi
    echo -e "${RED}Task not found: $task_id${NC}" >&2
    return 1
  fi

  local now; now=$(now_ms)
  sql_exec "UPDATE tasks SET status='done', summary='$(sql_escape "$summary")', completed_at=$now, updated_at=$now WHERE id='$(sql_escape "$full_tid")'"

  # Auto-store summary as memory so next agent knows what was done
  local goal_id; goal_id=$(sql_raw "SELECT goal_id FROM tasks WHERE id='$full_tid'")
  if [ -n "$goal_id" ]; then
    _sync_goal "$goal_id"
    local mem_id; mem_id=$(gen_id)
    sql_exec "INSERT INTO memories (id, goal_id, task_id, key, value, type, source, created_at) VALUES ('$(sql_escape "$mem_id")', '$(sql_escape "$goal_id")', '$(sql_escape "$full_tid")', 'completed_summary', '$(sql_escape "$summary")', 'completion', '$(sql_escape "$agent")', $now)"
  fi
  _track "complete" "$full_tid" "$goal_id"

  local title; title=$(sql_raw "SELECT title FROM tasks WHERE id='$full_tid'")
  if [ "$OUTPUT" = "json" ]; then
    local goal_status=""; [ -n "$goal_id" ] && goal_status=$(sql_raw "SELECT status FROM goals WHERE id='$goal_id'")
    echo "{\"ok\":true,\"id\":\"$full_tid\",\"status\":\"done\",\"title\":\"$title\",\"goal_status\":\"$goal_status\"}"
    return
  fi
  if [ "$OUTPUT" = "toon" ]; then
    echo "complete[1]{id,title,goal_status}:"
    local gs=""; [ -n "$goal_id" ] && gs=$(sql_raw "SELECT status FROM goals WHERE id='$(sql_escape "$goal_id")'")
    echo "  $(toon_escape "$full_tid"),$(toon_escape "$title"),$(toon_escape "$gs")"
    return
  fi
  echo -e "${GREEN}●${NC} Completed: ${BOLD}$title${NC}"
}

cmd_memory() {
  ensure_db
  local action="${1:-list}"
  
  case "$action" in
    list)
      echo -e "${BOLD}Memories${NC}"
      echo ""
      while IFS='|' read -r mid mkey mvalue msource gname; do
        [ -z "$mid" ] && continue
        echo -e "  ${BOLD}$mkey${NC}: $mvalue"
        echo -e "    ${DIM}source=$msource  goal=$gname  ${mid:0:10}${NC}"
      done < <(sql_raw "SELECT m.id, m.key, m.value, m.source, g.name FROM memories m LEFT JOIN goals g ON m.goal_id=g.id ORDER BY m.created_at DESC" ".separator |")
      local total
      total=$(sql_raw "SELECT count(*) FROM memories")
      [ "$total" = "0" ] && echo -e "  ${DIM}(none yet — memories are created when agents complete tasks)${NC}"
      ;;
    add)
      local goal_id="${2:?Usage: imi memory add <goal_id> <key> <value>}"
      local key="${3:?Usage: imi memory add <goal_id> <key> <value>}"
      local value="${4:?Usage: imi memory add <goal_id> <key> <value>}"
      
      local full_gid
      full_gid=$(sql_raw "SELECT id FROM goals WHERE id LIKE '${goal_id}%' LIMIT 1")
      if [ -z "$full_gid" ]; then
        echo -e "${RED}Goal not found: $goal_id${NC}"
        return 1
      fi
      
      local id
      id=$(gen_id)
      sql_exec "INSERT INTO memories (id, goal_id, key, value, source, created_at) VALUES ('$(sql_escape "$id")', '$(sql_escape "$full_gid")', '$(sql_escape "$key")', '$(sql_escape "$value")', 'user', $(now_ms))"
      if [ "$OUTPUT" = "json" ]; then
        echo "{\"ok\":true,\"id\":\"$id\",\"key\":\"$key\",\"value\":\"$value\",\"goal_id\":\"$full_gid\"}"
        return
      fi
      echo -e "${GREEN}●${NC} Memory stored: ${BOLD}$key${NC} = $value"
      ;;
    *)
      echo "Usage: imi memory [list|add <goal_id> <key> <value>]"
      ;;
  esac
}

cmd_next() {
  ensure_db
  local stale_ms stale_count
  stale_ms=$(( $(now_ms) - 1800000 ))
  stale_count=$(sql_raw "SELECT count(*) FROM tasks WHERE status='in_progress' AND updated_at < $stale_ms" 2>/dev/null || echo "0")
  _unlock_stale
  _track "next" "" ""

  local agent; agent=$(current_user)
  if [ "${1:-}" = "--agent" ]; then
    local agent_name="${2:-}"
    if [ -z "$agent_name" ]; then
      if machine_out; then echo '{"ok":false,"error":"Usage: imi next [--agent <name>] [goal_id]"}'; fi
      return 1
    fi
    agent="$agent_name"
    shift 2
  fi
  local goal_filter="${1:-}"

  if [ "$stale_count" != "0" ]; then
    if [ "$OUTPUT" = "toon" ]; then
      echo "stale_released[1]{note}:"
      echo "  $(toon_escape "$stale_count stale task(s) released back to todo")"
    elif [ "$OUTPUT" = "human" ]; then
      echo -e "${YELLOW}⚠${NC} $stale_count stale task(s) released back to todo"
    fi
  fi

  # Atomic claim: single UPDATE that grabs highest-priority todo task
  local now; now=$(now_ms)

  local where="t.status='todo'"
  if [ -n "$goal_filter" ]; then
    local full_gid; full_gid=$(sql_raw "SELECT id FROM goals WHERE id LIKE '$(sql_escape "$goal_filter")%' LIMIT 1")
    [ -n "$full_gid" ] && where="$where AND t.goal_id='$(sql_escape "$full_gid")'"
  fi

  # Grab candidate (lowest priority rank + oldest)
  local tid
  tid=$(sql_raw "SELECT t.id FROM tasks t WHERE $where ORDER BY CASE t.priority WHEN 'critical' THEN 0 WHEN 'high' THEN 1 WHEN 'medium' THEN 2 ELSE 3 END, t.created_at ASC LIMIT 1")

  if [ -z "$tid" ]; then
    if [ "$OUTPUT" = "json" ]; then echo '{"ok":false,"error":"no_tasks_available"}'; return 0; fi
    if [ "$OUTPUT" = "toon" ]; then echo "no_tasks[1]{note}:"; echo "  all_done_or_claimed"; return 0; fi
    echo -e "${DIM}No tasks available.${NC}"; return 0
  fi

  # Atomic claim
  sql_exec "UPDATE tasks SET status='in_progress', agent_id='$(sql_escape "$agent")', updated_at=$now WHERE id='$(sql_escape "$tid")' AND status='todo'"

  # Verify we actually got it (another agent may have raced us)
  local claimed; claimed=$(sql_raw "SELECT id FROM tasks WHERE id='$tid' AND agent_id='$(sql_escape "$agent")' AND status='in_progress'")
  if [ -z "$claimed" ]; then
    if [ "$OUTPUT" = "json" ]; then echo '{"ok":false,"error":"race_lost_try_again"}'; return 0; fi
    if [ "$OUTPUT" = "toon" ]; then echo "race_lost[1]{note}:"; echo "  try_again"; return 0; fi
    echo -e "${YELLOW}Race lost — another agent claimed this task. Run \`imi next\` again.${NC}"; return 0
  fi

  local goal_id; goal_id=$(sql_raw "SELECT goal_id FROM tasks WHERE id='$tid'")
  [ -n "$goal_id" ] && _sync_goal "$goal_id"
  _track "next" "$tid" "$goal_id"

  # Build rich context output
  local title desc why g_name g_why g_for_who g_success last_attempt
  title=$(sql_raw "SELECT title FROM tasks WHERE id='$tid'")
  desc=$(sql_raw "SELECT description FROM tasks WHERE id='$tid'")
  why=$(sql_raw "SELECT why FROM tasks WHERE id='$tid'")
  g_name=$(sql_raw "SELECT name FROM goals WHERE id='$(sql_escape "$goal_id")'")
  g_why=$(sql_raw "SELECT why FROM goals WHERE id='$(sql_escape "$goal_id")'")
  g_for_who=$(sql_raw "SELECT for_who FROM goals WHERE id='$(sql_escape "$goal_id")'")
  g_success=$(sql_raw "SELECT success_signal FROM goals WHERE id='$(sql_escape "$goal_id")'")
  last_attempt=$(sql_raw "SELECT value FROM memories WHERE task_id='$(sql_escape "$tid")' AND type='failure' ORDER BY created_at DESC LIMIT 1")

  if [ "$OUTPUT" = "json" ]; then
    sql_json "SELECT json_object(
      'ok',1,'task_id','$tid','title','$(sql_escape "$title")',
      'description','$(sql_escape "$desc")','why','$(sql_escape "$why")',
      'goal',json_object('id','$(sql_escape "$goal_id")','name','$(sql_escape "$g_name")',
        'why','$(sql_escape "$g_why")','for_who','$(sql_escape "$g_for_who")','success_signal','$(sql_escape "$g_success")'),
      'last_failure','$(sql_escape "$last_attempt")',
      'decisions',(SELECT json_group_array(json_object('what',what,'why',why)) FROM decisions ORDER BY created_at DESC LIMIT 3),
      'direction',(SELECT json_group_array(content) FROM direction_notes ORDER BY created_at DESC LIMIT 3)
    )"
    return
  fi

  if [ "$OUTPUT" = "toon" ]; then
    echo "task[1]{id,title,why}:"
    echo "  $(toon_escape "$tid"),$(toon_escape "$title"),$(toon_escape "$why")"
    echo "desc[1]{text}:"
    echo "  $(toon_escape "$desc")"
    echo "goal[1]{name,why,for_who,success}:"
    echo "  $(toon_escape "$g_name"),$(toon_escape "$g_why"),$(toon_escape "$g_for_who"),$(toon_escape "$g_success")"
    toon_section "decisions" "what,why" \
      "$(sql_raw "SELECT what||'|'||why FROM decisions ORDER BY created_at DESC LIMIT 3")"
    toon_section "direction" "note" \
      "$(sql_raw "SELECT content FROM direction_notes ORDER BY created_at DESC LIMIT 3")"
    [ -n "$last_attempt" ] && echo "last_failure[1]{reason}:" && echo "  $(toon_escape "$last_attempt")"
    toon_section "memories" "key,value,type" \
      "$(sql_raw "SELECT key||'|'||value||'|'||coalesce(type,'') FROM memories WHERE goal_id='$(sql_escape "$goal_id")' ORDER BY created_at DESC LIMIT 5")"
    return 0
  fi

  echo -e "${YELLOW}◐${NC} Claimed: ${BOLD}$title${NC}  ${DIM}@${agent}${NC}"
  echo -e "  ${DIM}task: $tid${NC}"
  [ -n "$why" ] && echo -e "  ${DIM}why: $why${NC}"
  [ -n "$desc" ] && echo -e "  ${DIM}$desc${NC}"
  echo -e "  ${DIM}goal: $g_name${NC}"
  [ -n "$g_why" ] && echo -e "  ${DIM}goal-why: $g_why${NC}"
  [ -n "$last_attempt" ] && echo -e "  ${RED}last failure: $last_attempt${NC}"
}

cmd_fail() {
  ensure_db
  local agent; agent=$(current_user)
  if [ "${1:-}" = "--agent" ]; then
    local agent_name="${2:-}"
    if [ -z "$agent_name" ]; then
      if machine_out; then echo '{"ok":false,"error":"Usage: imi fail [--agent <name>] <task_id> <reason>"}'; fi
      return 1
    fi
    agent="$agent_name"
    shift 2
  fi
  local task_id="${1:?Usage: imi fail [--agent <name>] <task_id> <reason>}"
  local reason="${2:?Usage: imi fail [--agent <name>] <task_id> <reason>}"

  local full_tid; full_tid=$(sql_raw "SELECT id FROM tasks WHERE id LIKE '$(sql_escape "$task_id")%' LIMIT 1")
  if [ -z "$full_tid" ]; then
    if machine_out; then echo '{"ok":false,"error":"Task not found: '"$task_id"'"}';
    else echo -e "${RED}✕ Task not found: $task_id${NC}"; fi
    return 1
  fi

  local now; now=$(now_ms)
  sql_exec "UPDATE tasks SET status='todo', agent_id=NULL, updated_at=$now WHERE id='$(sql_escape "$full_tid")'"

  # Store failure reason as memory so next agent knows what was tried
  local goal_id; goal_id=$(sql_raw "SELECT goal_id FROM tasks WHERE id='$full_tid'")
  local mem_id; mem_id=$(gen_id)
  sql_exec "INSERT INTO memories (id, goal_id, task_id, key, value, type, source, created_at) VALUES ('$(sql_escape "$mem_id")', '$(sql_escape "$goal_id")', '$(sql_escape "$full_tid")', 'failure_reason', '$(sql_escape "$reason")', 'failure', '$(sql_escape "$agent")', $now)"

  [ -n "$goal_id" ] && _sync_goal "$goal_id"
  _track "fail" "$full_tid" "$goal_id"

  local title; title=$(sql_raw "SELECT title FROM tasks WHERE id='$full_tid'")
  if [ "$OUTPUT" = "json" ]; then echo "{\"ok\":true,\"id\":\"$full_tid\",\"status\":\"todo\",\"title\":\"$title\"}"; return; fi
  if [ "$OUTPUT" = "toon" ]; then echo "fail[1]{id,status}:"; echo "  $(toon_escape "$full_tid"),todo"; return; fi
  echo -e "${RED}✕${NC} Failed: ${BOLD}$title${NC}"
  echo -e "  ${DIM}reason stored — next agent will see it via \`imi next\`${NC}"
}

cmd_ping() {
  ensure_db
  local task_id="${1:?Usage: imi ping <task_id>}"

  local full_tid; full_tid=$(sql_raw "SELECT id FROM tasks WHERE id LIKE '$(sql_escape "$task_id")%' LIMIT 1")
  if [ -z "$full_tid" ]; then
    if machine_out; then echo '{"ok":false,"error":"Task not found"}'; fi
    return 1
  fi

  sql_exec "UPDATE tasks SET updated_at=$(now_ms) WHERE id='$(sql_escape "$full_tid")' AND status='in_progress'"
  _track "ping" "$full_tid" ""
  local title; title=$(sql_raw "SELECT title FROM tasks WHERE id='$full_tid'")
  if [ "$OUTPUT" = "json" ]; then echo "{\"ok\":true,\"id\":\"$full_tid\",\"alive\":true}"; return; fi
  if [ "$OUTPUT" = "toon" ]; then echo "ping[1]{id,alive}:"; echo "  $(toon_escape "$full_tid"),1"; return; fi
  echo -e "${DIM}♡ alive: $title${NC}"
}


cmd_decide() {
  ensure_db
  local what="${1:?Usage: imi decide <what-changed> <why> [affects]}"
  local why="${2:?Usage: imi decide <what-changed> <why> [affects]}"
  local affects="${3:-}"
  local id
  id=$(gen_id)
  sql_exec "INSERT INTO decisions (id, what, why, affects, created_at) VALUES ('$(sql_escape "$id")', '$(sql_escape "$what")', '$(sql_escape "$why")', '$(sql_escape "$affects")', $(now_ms))"
  if [ "$OUTPUT" = "json" ]; then
    echo "{\"ok\":true,\"id\":\"$id\",\"what\":\"$what\"}"
    return
  fi
  if [ "$OUTPUT" = "toon" ]; then
    echo "decide[1]{id,what,why,affects}:"
    echo "  $(toon_escape "$id"),$(toon_escape "$what"),$(toon_escape "$why"),$(toon_escape "$affects")"
    return
  fi
  echo -e "${CYAN}◆${NC} Decision logged: ${BOLD}$what${NC}"
  echo -e "  ${DIM}why: $why${NC}"
  [ -n "$affects" ] && echo -e "  ${DIM}affects: $affects${NC}"
}

cmd_log() {
  ensure_db
  local content="${1:?Usage: imi log <note>}"
  local author
  author=$(current_user)
  local id
  id=$(gen_id)
  sql_exec "INSERT INTO direction_notes (id, content, author, created_at) VALUES ('$(sql_escape "$id")', '$(sql_escape "$content")', '$(sql_escape "$author")', $(now_ms))"
  if [ "$OUTPUT" = "json" ]; then
    echo "{\"ok\":true,\"id\":\"$id\",\"content\":\"$content\"}"
    return
  fi
  if [ "$OUTPUT" = "toon" ]; then
    echo "log[1]{id,content,author}:"
    echo "  $(toon_escape "$id"),$(toon_escape "$content"),$(toon_escape "$author")"
    return
  fi
  echo -e "${YELLOW}▸${NC} Logged: $content"
  echo -e "  ${DIM}@$author${NC}"
}


cmd_delete() {
  ensure_db
  local target="${1:?Usage: imi delete <goal_id|task_id>}"
  
  # Try as goal first
  local gid
  gid=$(sql_raw "SELECT id FROM goals WHERE id LIKE '${target}%' LIMIT 1")
  if [ -n "$gid" ]; then
    local gname task_count
    gname=$(sql_raw "SELECT name FROM goals WHERE id='$gid'")
    task_count=$(sql_raw "SELECT count(*) FROM tasks WHERE goal_id='$gid'")
    sql_exec "DELETE FROM memories WHERE goal_id='$gid'"
    sql_exec "DELETE FROM tasks WHERE goal_id='$gid'"
    sql_exec "DELETE FROM goals WHERE id='$gid'"
    if [ "$OUTPUT" = "json" ]; then
      echo "{\"ok\":true,\"deleted\":\"goal\",\"id\":\"$gid\",\"name\":\"$gname\",\"tasks_deleted\":$task_count}"
      return 0
    fi
    echo -e "${RED}✕${NC} Deleted goal: ${BOLD}$gname${NC} (+ $task_count tasks)"
    return 0
  fi
  
  # Try as task
  local tid
  tid=$(sql_raw "SELECT id FROM tasks WHERE id LIKE '${target}%' LIMIT 1")
  if [ -n "$tid" ]; then
    local ttitle goal_id
    ttitle=$(sql_raw "SELECT title FROM tasks WHERE id='$tid'")
    goal_id=$(sql_raw "SELECT goal_id FROM tasks WHERE id='$tid'")
    sql_exec "DELETE FROM memories WHERE task_id='$tid'"
    sql_exec "DELETE FROM tasks WHERE id='$tid'"
    [ -n "$goal_id" ] && _sync_goal "$goal_id"
    if [ "$OUTPUT" = "json" ]; then
      echo "{\"ok\":true,\"deleted\":\"task\",\"id\":\"$tid\",\"title\":\"$ttitle\"}"
      return 0
    fi
    echo -e "${RED}✕${NC} Deleted task: ${BOLD}$ttitle${NC}"
    return 0
  fi

  if [ "$OUTPUT" = "json" ]; then echo "{\"ok\":false,\"error\":\"Not found: $target\"}"; fi
  echo -e "${RED}Not found: $target${NC}"
  return 1
}

cmd_reset() {
  ensure_db
  local force="${1:-}"
  if [ "$force" != "--force" ] && [ "$force" != "-f" ]; then
    echo -e "${RED}${BOLD}⚠  This will delete ALL goals, tasks, and memories.${NC}"
    read -p "Type 'yes' to confirm: " confirm
    [ "$confirm" != "yes" ] && echo "Cancelled." && return
  fi
  sql_exec "DELETE FROM memories"
  sql_exec "DELETE FROM tasks"
  sql_exec "DELETE FROM goals"
  if [ "$OUTPUT" = "json" ]; then
    echo '{"ok":true,"action":"reset"}'
    return
  fi
  echo -e "${GREEN}●${NC} Reset complete. Clean slate."
}

# --- Internal ---

_sync_goal() {
  local goal_id="$1"
  local now
  now=$(now_ms)
  sql_exec "UPDATE goals SET
    status = CASE
      WHEN NOT EXISTS(SELECT 1 FROM tasks WHERE goal_id='$(sql_escape "$goal_id")') THEN 'todo'
      WHEN EXISTS(SELECT 1 FROM tasks WHERE goal_id='$(sql_escape "$goal_id")' AND status='in_progress') THEN 'ongoing'
      WHEN EXISTS(SELECT 1 FROM tasks WHERE goal_id='$(sql_escape "$goal_id")' AND status='review') THEN 'review'
      WHEN NOT EXISTS(SELECT 1 FROM tasks WHERE goal_id='$(sql_escape "$goal_id")' AND status!='done') THEN 'done'
      WHEN EXISTS(SELECT 1 FROM tasks WHERE goal_id='$(sql_escape "$goal_id")' AND status='done') THEN 'ongoing'
      ELSE 'todo'
    END,
    completed_at = CASE
      WHEN NOT EXISTS(SELECT 1 FROM tasks WHERE goal_id='$(sql_escape "$goal_id")' AND status!='done')
           AND EXISTS(SELECT 1 FROM tasks WHERE goal_id='$(sql_escape "$goal_id")') THEN $now
      ELSE NULL
    END,
    updated_at = $now
  WHERE id='$(sql_escape "$goal_id")'"
}

cmd_run() {
  ensure_db
  local task_id="${1:?Usage: imi run <task_id> [model]}"
  local model="${2:-sonnet}"

  local full_tid
  full_tid=$(sql_raw "SELECT id FROM tasks WHERE id LIKE '$(sql_escape "$task_id")%' LIMIT 1")
  [ -z "$full_tid" ] && echo -e "${RED}Task not found: $task_id${NC}" && return 1

  local title desc why goal_id
  title=$(sql_raw "SELECT title FROM tasks WHERE id='$(sql_escape "$full_tid")'")
  desc=$(sql_raw "SELECT description FROM tasks WHERE id='$(sql_escape "$full_tid")'")
  why=$(sql_raw "SELECT why FROM tasks WHERE id='$(sql_escape "$full_tid")'")
  goal_id=$(sql_raw "SELECT goal_id FROM tasks WHERE id='$(sql_escape "$full_tid")'")

  local g_name g_why g_for g_success
  g_name=$(sql_raw "SELECT name FROM goals WHERE id='$(sql_escape "$goal_id")'")
  g_why=$(sql_raw "SELECT why FROM goals WHERE id='$(sql_escape "$goal_id")'")
  g_for=$(sql_raw "SELECT for_who FROM goals WHERE id='$(sql_escape "$goal_id")'")
  g_success=$(sql_raw "SELECT success_signal FROM goals WHERE id='$(sql_escape "$goal_id")'")

  local db_dir; db_dir="$(dirname "$DB_PATH")"
  local run_dir="${db_dir}/runs/${full_tid}"
  local exec_dir="${run_dir}/exec"
  mkdir -p "$run_dir/prompts"

  # Build prompt from IMI context
  {
    echo "# IMI Task: $title"
    echo ""
    echo "## Goal"
    echo "**$g_name**"
    [ -n "$g_why" ] && echo "Why: $g_why"
    [ -n "$g_for" ] && echo "For: $g_for"
    [ -n "$g_success" ] && echo "Done when: $g_success"
    echo ""
    echo "## Your Task"
    echo "**$title**"
    [ -n "$why" ] && echo "Why: $why"
    [ -n "$desc" ] && echo "" && echo "$desc"
    echo ""
    echo "## Instructions"
    echo "The project source is in \`read_only_data_source/\` — reference only."
    echo "Do your work in the execution workspace."
    echo "When done, write \`summary.md\` with: what you did, key decisions, any blockers."

    local memories
    memories=$(sql_raw "SELECT '- ['||key||'] '||value FROM memories WHERE goal_id='$(sql_escape "$goal_id")' ORDER BY created_at DESC LIMIT 10")
    if [ -n "$memories" ]; then
      echo ""
      echo "## Memories from previous agents"
      echo "$memories"
    fi

    local decisions
    decisions=$(sql_raw "SELECT '- '||what||' (why: '||why||')' FROM decisions ORDER BY created_at DESC LIMIT 5")
    if [ -n "$decisions" ]; then
      echo ""
      echo "## Strategic Decisions"
      echo "$decisions"
    fi
  } > "$run_dir/prompts/task.md"

  # Write hank.json with safe JSON encoding
  python3 -c "
import json, sys
title, model = sys.argv[1], sys.argv[2]
hank = {
  '\$schema': 'https://unpkg.com/hankweave@latest/schemas/hank.schema.json',
  'meta': {'name': 'IMI: ' + title, 'version': '1.0.0', 'description': 'Generated by imi run'},
  'hank': [{
    'id': 'execute-task',
    'name': title,
    'model': model,
    'continuationMode': 'fresh',
    'promptFile': './prompts/task.md',
    'checkpointedFiles': ['workspace/**'],
    'outputFiles': [{'copy': ['summary.md']}]
  }]
}
print(json.dumps(hank, indent=2))
" "$title" "$model" > "$run_dir/hank.json"

  # Mark task in-progress
  local agent; agent=$(current_user)
  local now; now=$(now_ms)
  sql_exec "UPDATE tasks SET status='in_progress', agent_id='$(sql_escape "$agent")', updated_at=$now WHERE id='$(sql_escape "$full_tid")'"
  [ -n "$goal_id" ] && _sync_goal "$goal_id"

  echo -e "${YELLOW}◐${NC} Running: ${BOLD}$title${NC}"
  echo -e "  ${DIM}task:  $full_tid${NC}"
  echo -e "  ${DIM}model: $model${NC}"
  echo -e "  ${DIM}run:   $run_dir${NC}"
  echo ""

  local project_root; project_root="$(dirname "$db_dir")"
  local exit_code=0
  bunx hankweave --config "$run_dir/hank.json" --data "$project_root" -e "$exec_dir" -y || exit_code=$?

  echo ""
  if [ $exit_code -eq 0 ]; then
    local summary=""
    [ -f "$exec_dir/summary.md" ] && summary=$(head -5 "$exec_dir/summary.md" | tr '\n' ' ')
    echo -e "${GREEN}●${NC} Done. Output: ${DIM}$exec_dir${NC}"
    [ -n "$summary" ] && echo -e "  ${DIM}$summary${NC}"
    echo -e "  ${DIM}→ imi complete $full_tid \"your summary\"${NC}"
  else
    echo -e "${RED}✕${NC} Run failed (exit $exit_code)"
    echo -e "  ${DIM}Resume: bunx hankweave -e $exec_dir${NC}"
    echo -e "  ${DIM}→ imi fail $full_tid \"reason\"${NC}"
  fi
}

# --- Main ---

cmd_stats() {
  ensure_db

  local total done_count wip_count todo_count
  total=$(sql_raw "SELECT count(*) FROM tasks")
  done_count=$(sql_raw "SELECT count(*) FROM tasks WHERE status='done'")
  wip_count=$(sql_raw "SELECT count(*) FROM tasks WHERE status='in_progress'")
  todo_count=$(sql_raw "SELECT count(*) FROM tasks WHERE status='todo'")

  local fail_count complete_count
  fail_count=$(sql_raw "SELECT count(*) FROM memories WHERE type='failure'")
  complete_count=$(sql_raw "SELECT count(*) FROM memories WHERE type='completion'")

  local cycle_ms
  cycle_ms=$(sql_raw "SELECT CAST(AVG(completed_at - created_at) AS INTEGER) FROM tasks WHERE status='done' AND completed_at IS NOT NULL AND created_at IS NOT NULL")

  local stale_count
  stale_count=$(sql_raw "SELECT count(*) FROM direction_notes WHERE content LIKE 'Stale lock%'")

  local week_ago
  week_ago=$(python3 -c "import time; print(int((time.time()-7*86400)*1000))" 2>/dev/null || echo "0")

  local ctx_calls next_calls total_events
  ctx_calls=$(sql_raw "SELECT count(*) FROM events WHERE command='context' AND created_at>${week_ago}")
  next_calls=$(sql_raw "SELECT count(*) FROM events WHERE command='next' AND created_at>${week_ago}")
  total_events=$(sql_raw "SELECT count(*) FROM events")

  if [ "$OUTPUT" = "toon" ]; then
    echo "stats[1]{tasks,done,wip,todo,failures,completions,stale_locks,ctx_7d,next_7d,events_total}:"
    echo "  $total,$done_count,$wip_count,$todo_count,$fail_count,$complete_count,$stale_count,$ctx_calls,$next_calls,$total_events"
    return
  fi

  if [ "$OUTPUT" = "json" ]; then
    echo "{\"tasks\":{\"total\":$total,\"done\":$done_count,\"wip\":$wip_count,\"todo\":$todo_count},\"memories\":{\"failures\":$fail_count,\"completions\":$complete_count},\"stale_locks\":$stale_count,\"agent_activity_7d\":{\"context\":$ctx_calls,\"next\":$next_calls},\"events_total\":$total_events}"
    return
  fi

  echo -e "${BOLD}IMI Stats${NC}  ${DIM}(effectiveness signals)${NC}"
  echo ""

  echo -e "${BOLD}Tasks${NC}"
  echo -e "  total=${BOLD}$total${NC}  done=${GREEN}$done_count${NC}  wip=${YELLOW}$wip_count${NC}  todo=${DIM}$todo_count${NC}"

  local denom=$(( done_count + fail_count ))
  if [ "$denom" -gt 0 ]; then
    local rate=$(( done_count * 100 / denom ))
    local rate_color="$GREEN"
    [ "$rate" -lt 70 ] && rate_color="$YELLOW"
    [ "$rate" -lt 40 ] && rate_color="$RED"
    echo -e "  completion rate: ${rate_color}${rate}%${NC}  (${done_count} done / ${fail_count} failures)"
  fi

  if [ -n "$cycle_ms" ] && [ "$cycle_ms" != "" ] && [ "$cycle_ms" != "NULL" ] && [ "$cycle_ms" != "0" ]; then
    local cycle_h
    cycle_h=$(python3 -c "ms=int('$cycle_ms'); print(f'{ms/3600000:.1f}h' if ms>=3600000 else f'{ms/60000:.0f}min')" 2>/dev/null || echo "${cycle_ms}ms")
    echo -e "  avg task cycle time: ${cycle_h}"
  fi

  echo ""
  echo -e "${BOLD}Agent Activity (7d)${NC}"
  echo -e "  context calls: ${CYAN}$ctx_calls${NC}  (agents fetching context = engagement)"
  echo -e "  next claims:   ${CYAN}$next_calls${NC}  (tasks picked up by agents)"

  local top_cmds
  top_cmds=$(sql_raw "SELECT command||'  '||count(*)||'x' FROM events WHERE created_at>${week_ago} GROUP BY command ORDER BY count(*) DESC LIMIT 8" 2>/dev/null)
  if [ -n "$top_cmds" ]; then
    echo ""
    echo -e "${BOLD}Top Commands (7d)${NC}"
    while IFS= read -r line; do [ -n "$line" ] && echo -e "  ${DIM}$line${NC}"; done <<< "$top_cmds"
  fi

  echo ""
  echo -e "${BOLD}Health Signals${NC}"
  local g_total g_done
  g_total=$(sql_raw "SELECT count(*) FROM goals")
  g_done=$(sql_raw "SELECT count(*) FROM goals WHERE status='done'")
  echo -e "  goals: ${GREEN}$g_done${NC}/${g_total} done"
  echo -e "  stale lock auto-releases: ${stale_count}  (agent drop-offs — 0 is ideal)"
  echo -e "  total events logged: ${DIM}$total_events${NC}"
}

_imi_snippet() {
  cat <<'SNIPPET'
## IMI — AI Product Ops

This project uses `imi` — persistent goal/task/context state for AI agents.
Run `imi context --toon` before starting any work.

### Agent Workflow
1. `imi context --toon`              → Get current priorities, decisions, direction
2. `imi next --toon`                 → Atomically claim the highest-priority task
3. `imi ping <task_id>`              → Heartbeat every 10 min (auto-unlocks after 30min if you don't)
4. `imi complete <task_id> "<what you did and why>"`  → Mark done, store memory
5. `imi fail <task_id> "<why stuck>"` → Release for next agent if blocked

### Key Commands
- `imi status`                       → Dashboard
- `imi context --toon`               → Full context: direction, decisions, goals, WIP
- `imi decide "<what>" "<why>"`      → Log a strategic decision
- `imi log "<insight>"`              → Store a direction note
- `imi memory add <goal_id> <key> "<value>"` → Store a learning
- `imi stats`                        → Effectiveness signals (completion rate, cycle time)

### Rules
- NEVER skip `imi context` before starting — it's your briefing
- NEVER leave a task in_progress without `imi ping` — it auto-unlocks after 30min
- Always use `--toon` flag for machine output (30-60% fewer tokens than JSON)
- If a task shows `last_failure`, read it — don't repeat the same mistake
SNIPPET
}

cmd_instructions() {
  local tool="${1:-}"

  case "$tool" in
    cursor)
      echo "# Save as .cursor/rules/imi.mdc"
      echo "---"
      echo "description: IMI product ops — task claiming and context"
      echo "globs: [\"**/*\"]"
      echo "alwaysApply: true"
      echo "---"
      echo ""
      _imi_snippet
      ;;
    copilot)
      echo "# Add to .github/copilot-instructions.md"
      echo ""
      _imi_snippet
      ;;
    windsurf)
      echo "# Save as .windsurf/rules/imi.md"
      echo ""
      _imi_snippet
      ;;
    *)
      echo "# Add to CLAUDE.md  (or: imi instructions cursor|copilot|windsurf)"
      echo ""
      _imi_snippet
      ;;
  esac
}

cmd_help() {
  echo -e "${BOLD}imi${NC} — AI-native product ops state engine v${VERSION}"
  echo -e "${DIM}The shared brain for your AI coding agents.${NC}"
  echo ""
  echo -e "${BOLD}USAGE${NC}"
  echo "  imi <command> [args] [--toon|--json]"
  echo ""
  echo -e "${BOLD}COMMANDS${NC}"
  echo -e "  ${CYAN}status${NC}                               Dashboard: goals + tasks + stale warnings"
  echo -e "  ${CYAN}goals${NC}                                List all goals"
  echo -e "  ${CYAN}tasks${NC} [filter]                       List tasks (all|todo|wip|done|<goal_id>)"
  echo -e "  ${CYAN}context${NC} [goal_id]                    What matters right now (TOON by default for agents)"
  echo -e "  ${CYAN}memory${NC} [list|add ...]                View or store memories/insights"
  echo -e "  ${CYAN}stats${NC}                                Effectiveness signals: completion rate, cycle time, activity"
  echo ""
  echo -e "  ${CYAN}decide${NC} <what> <why> [affects]        Log a strategic decision"
  echo -e "  ${CYAN}log${NC} <note>                           Log a direction note (timestamped thought)"
  echo ""
  echo -e "  ${GREEN}next${NC} [goal_id]                      Atomically claim the next available task"
  echo -e "  ${GREEN}ping${NC} <task_id>                      Heartbeat — keep task from auto-unlocking (>30min)"
  echo -e "  ${GREEN}fail${NC} <task_id> <reason>             Release task lock, store failure reason for next agent"
  echo -e "  ${GREEN}run${NC} <task_id> [model]               Generate hank.json from task context + fire hankweave"
  echo ""
  echo -e "  ${GREEN}add-goal${NC} <name> [desc] [pri] [why] [for_who] [success]  Create a goal"
  echo -e "  ${GREEN}add-task${NC} <gid> <title> [desc] [pri] [why]               Add a task"
  echo -e "  ${GREEN}start${NC} <task_id>                     Mark task in-progress"
  echo -e "  ${GREEN}complete${NC} <tid> [summary]            Mark done (auto-stores summary as memory)"
  echo -e "  ${GREEN}init${NC}                                Initialize DB in current project (.imi/state.db)"
  echo -e "  ${GREEN}instructions${NC} [cursor|copilot|windsurf]  Print snippet to add IMI to your AI tool's rules"
  echo ""
  echo -e "  ${RED}delete${NC} <id>                          Delete a goal or task"
  echo -e "  ${RED}reset${NC} [--force]                      Delete everything"
  echo ""
  echo -e "${BOLD}FLAGS${NC}"
  echo -e "  ${DIM}--toon${NC}    Token-efficient output for AI agents (30-60% fewer tokens than JSON)"
  echo -e "  ${DIM}--json${NC}    Verbose machine-readable JSON"
  echo ""
  echo -e "${BOLD}FOR AI AGENTS${NC}  Add to CLAUDE.md or .github/copilot-instructions.md:"
  echo -e "  ${DIM}Use \`imi next --toon\` to claim your task. Use \`imi ping <id>\` every 10min."
  echo -e "  Use \`imi complete <id> \"what you did\"\` when done. Use \`imi fail <id> \"why\"\` if stuck.${NC}"
}

cmd_init() {
  local project_db="${PWD}/.imi/state.db"
  if [ -f "$project_db" ]; then
    echo -e "${DIM}Already initialized: $project_db${NC}"
    return
  fi
  DB_PATH="$project_db"
  _init_db
  # Register workspace
  local ws_id ws_name git_remote
  ws_id=$(gen_id)
  ws_name=$(basename "$PWD")
  git_remote=$(git remote get-url origin 2>/dev/null || echo "")
  sql_exec "INSERT OR IGNORE INTO workspaces (id, name, path, git_remote, created_at, updated_at) VALUES ('$(sql_escape "$ws_id")', '$(sql_escape "$ws_name")', '$(sql_escape "$PWD")', '$(sql_escape "$git_remote")', $(now_ms), $(now_ms))"
  echo -e "${GREEN}●${NC} Initialized IMI in ${BOLD}.imi/state.db${NC}"
  echo -e "${DIM}Workspace: $ws_name ($PWD)${NC}"
  echo -e "${DIM}Add .imi/ to .gitignore (or commit it for shared state)${NC}"
}

case "${1:-}" in
  status|s)       cmd_status ;;
  goals|g)        cmd_goals ;;
  tasks|t)        cmd_tasks "${2:-all}" ;;
  context|ctx|c)  cmd_context "${2:-}" ;;
  memory|mem|m)   cmd_memory "${2:-list}" "${3:-}" "${4:-}" "${5:-}" ;;
  decide|d)       cmd_decide "${2:-}" "${3:-}" "${4:-}" ;;
  log|l)          cmd_log "${2:-}" ;;
  next|n)         cmd_next "${@:2}" ;;
  ping)           cmd_ping "${2:-}" ;;
  fail)           cmd_fail "${@:2}" ;;
  stats|stat)       cmd_stats ;;
  instructions|inst) cmd_instructions "${2:-}" ;;
  add-goal|ag)    cmd_add_goal "${2:-}" "${3:-}" "${4:-}" "${5:-}" "${6:-}" "${7:-}" ;;
  add-task|at)    cmd_add_task "${2:-}" "${3:-}" "${4:-}" "${5:-}" "${6:-}" ;;
  start|st)       cmd_start "${2:-}" ;;
  complete|done)  cmd_complete "${@:2}" ;;
  delete|rm)      cmd_delete "${2:-}" ;;
  reset)          cmd_reset "${2:-}" ;;
  init)           cmd_init ;;
  help|--help|-h) cmd_help ;;
  version|--version|-v) echo "imi v${VERSION}" ;;
  "")             cmd_status ;;
  *)              echo -e "${RED}Unknown command: $1${NC}"; echo ""; cmd_help ;;
esac
